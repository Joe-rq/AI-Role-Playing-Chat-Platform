# 角色扮演AI对话平台 - 答辩文档（大白话版）

> **项目名称**：AI角色扮演对话平台  
> **开发者**：AI + 开发培训学员  
> **答辩目标**：让完全不懂技术的人也能听懂这个项目做了什么

---

## 一、这个项目到底是干嘛的？

### 1.1 一句话说明

简单来说，这就是一个**"可以和虚拟角色聊天"的网站**。

想象你打开一个网页，里面有几个虚拟人物——比如傲娇的魔法少女、温柔的邻家姐姐、冷酷的赛博黑客。你可以跟他们聊天，他们会根据自己的人设回复你，就像真的在跟不同的人聊天一样。

### 1.2 核心功能

| 功能 | 用大白话解释 |
|------|-------------|
| **角色扮演** | 每个AI都有自己的人设（比如性格、说话方式），回复时会保持这个人设 |
| **流式打字** | AI回复不是一下子全出来，而是一个字一个字"打"出来，像真人打字 |
| **发图片** | 你可以给AI发图片，AI能"看懂"图片内容并回复 |
| **记忆功能** | AI能记住你们之前的聊天内容，下次聊时还能接上话 |
| **多模型支持** | 可以切换不同的AI大脑（比如GPT-4、Claude等） |

### 1.3 举个例子

假设你创建了一个角色叫"傲娇魔法少女"，人设是："你是个傲娇的魔法少女，说话带点任性但其实很善良，喜欢用表情符号"。

**你问**："你好，你是谁？"

**她可能会回**："哼，本小姐的名字可不是随便告诉别人的！（叉腰）不过既然你诚心诚意地发问了...我叫Lina，是守护这片土地的魔法少女啦~ ⭐"

看，回复就带上了傲娇的语气、表情符号，符合人设。

---

## 二、这个系统是怎么设计的？

### 2.1 整体架构：用餐厅来比喻

如果把整个系统比作一家餐厅：

```
顾客（用户）
    ↓
服务员（前端网页）—— 负责接待、点餐、上菜
    ↓
后厨（后端服务器）—— 负责做菜（调用AI）
    ↓
食材仓库（数据库）—— 存储菜单、顾客信息、订单记录
    ↓
外部供应商（AI服务商）—— 提供AI大脑
```

**对应关系：**
- **前端（服务员）**：用户直接看到的网页界面，负责展示页面、接收用户输入、显示AI回复
- **后端（后厨）**：处理业务逻辑，调用AI接口，管理数据
- **数据库（仓库）**：存储角色信息、聊天记录、用户配置
- **外部AI服务（供应商）**：OpenAI、Claude等提供AI能力

### 2.2 前端长什么样？

前端就是用户看到的网页，用 **Vue 3** 框架写的。

**前端目录结构：**
```
frontend/src/
├── views/              # 页面级组件
│   ├── Home.vue       # 首页（角色列表）
│   ├── Chat.vue       # 聊天界面
│   └── ModelManagement.vue  # 模型管理
├── components/        # 可复用组件
│   ├── ChatBubble.vue # 聊天气泡
│   ├── CharacterCard.vue  # 角色卡片
│   └── Toast.vue      # 消息提示
├── composables/       # 组合式函数（复用逻辑）
│   ├── useChatHistory.js  # 管理聊天记录
│   └── useToast.js    # 管理消息提示
└── services/          # API封装
    └── api.js         # 所有后端接口调用
```

**举个例子：聊天消息怎么管理？**

用 `useChatHistory.js` 这个组合式函数来管理：

```javascript
// 这个函数就像一个"管家"，专门管理聊天记录
export function useChatHistory(characterId) {
  // 存储消息的数组（响应式，数据变化界面自动更新）
  const messages = ref([])
  
  // 生成会话标识
  const sessionKey = ref(generateSessionKey())
  
  // 添加消息
  const addMessage = (role, content) => {
    messages.value.push({
      id: Date.now(),
      role,      // 'user' 或 'assistant'
      content,   // 消息内容
      timestamp: new Date()
    })
    // 自动保存到本地存储
    saveToLocalStorage()
  }
  
  // 加载历史记录
  const loadHistory = () => {
    const saved = localStorage.getItem(`chat_${sessionKey.value}`)
    if (saved) {
      messages.value = JSON.parse(saved)
    }
  }
  
  // 初始化时加载历史
  onMounted(() => {
    loadHistory()
  })
  
  return {
    messages,
    sessionKey,
    addMessage,
    loadHistory
  }
}
```

**好处是什么？**
- 任何页面想管理聊天记录，只要调用 `useChatHistory()` 就行
- 逻辑和界面分离，代码更好维护
- 自动处理数据持久化（localStorage）

### 2.3 后端是怎么设计的？

后端用 **NestJS** 框架，采用模块化设计。

**后端目录结构：**
```
backend/src/
├── characters/        # 角色管理模块
│   ├── entities/      # 数据库实体
│   ├── dto/           # 数据传输对象
│   ├── characters.controller.ts
│   ├── characters.service.ts
│   └── characters.module.ts
├── chat/              # 聊天模块（核心）
│   ├── chat.controller.ts
│   ├── chat.service.ts
│   └── chat.gateway.ts
├── upload/            # 文件上传模块
├── models/            # AI模型管理模块
└── main.ts            # 应用入口
```

**模块化设计的好处：**
- 每个模块职责单一，代码清晰
- 模块之间可以复用和组合
- 便于团队协作，每人负责一个模块

**举个例子：角色模块（CharactersModule）**

```typescript
// characters.service.ts - 处理业务逻辑
@Injectable()
export class CharactersService {
  constructor(
    @InjectRepository(Character)
    private characterRepository: Repository<Character>
  ) {}

  // 创建角色
  async create(createDto: CreateCharacterDto): Promise<Character> {
    const character = this.characterRepository.create(createDto)
    return this.characterRepository.save(character)
  }

  // 查询所有角色
  async findAll(): Promise<Character[]> {
    return this.characterRepository.find()
  }

  // 根据ID查询角色
  async findOne(id: number): Promise<Character> {
    const character = await this.characterRepository.findOne({ where: { id } })
    if (!character) {
      throw new NotFoundException(`角色 #${id} 不存在`)
    }
    return character
  }
}
```

**Controller负责接收请求和返回响应：**

```typescript
// characters.controller.ts
@Controller('characters')
export class CharactersController {
  constructor(private readonly charactersService: CharactersService) {}

  @Post() // POST /characters - 创建角色
  create(@Body() createDto: CreateCharacterDto) {
    return this.charactersService.create(createDto)
  }

  @Get() // GET /characters - 获取所有角色
  findAll() {
    return this.charactersService.findAll()
  }

  @Get(':id') // GET /characters/1 - 获取单个角色
  findOne(@Param('id') id: string) {
    return this.charactersService.findOne(+id)
  }

  @Put(':id') // PUT /characters/1 - 更新角色
  update(@Param('id') id: string, @Body() updateDto: UpdateCharacterDto) {
    return this.charactersService.update(+id, updateDto)
  }

  @Delete(':id') // DELETE /characters/1 - 删除角色
  remove(@Param('id') id: string) {
    return this.charactersService.remove(+id)
  }
}
```

**总结一下后端设计的核心思想：**

1. **分层架构**：Controller（接收请求）→ Service（业务逻辑）→ Repository（数据访问）
2. **依赖注入**：NestJS自动管理对象创建和依赖关系，代码更松耦合
3. **装饰器模式**：使用`@Controller`、`@Get`等装饰器声明式定义路由
4. **DTO验证**：使用class-validator自动验证请求数据格式

这样设计的好处是：
- 代码结构清晰，每个文件职责单一
- 易于测试，每层都可以独立测试
- 易于维护，修改一处不会影响其他地方
- 团队协作方便，不同人负责不同模块

---

## 三、数据是怎么流转的？

### 3.1 从用户发消息到AI回复的完整流程

**用餐厅点餐来类比：**

1. **顾客点餐（用户发消息）**
   - 你在聊天框输入"你好"
   - 前端就像服务员，把你的消息记下来

2. **服务员传给后厨（前端发送请求）**
   - 服务员拿着你的订单（消息内容），走到后厨（后端服务器）
   - 同时告诉后厨："这位顾客之前聊过什么什么（历史记录）"

3. **后厨准备食材（后端处理请求）**
   - 厨师长（Controller）接到订单，分配给具体的厨师（Service）
   - 厨师开始准备：
     - 拿出这个角色的"人设说明书"（System Prompt）
     - 翻看之前的聊天记录（History）
     - 把顾客的新消息（User Message）放在一起

4. **调用外部AI（联系食材供应商）**
   - 厨师把这些材料打包，发给外部的AI服务商（如OpenAI）
   - 就像餐厅打电话给供应商："我们需要这种食材，请按这个配方做出来"

5. **AI生成回复（供应商制作食材）**
   - AI开始一个字一个字地生成回复
   - 每生成一部分，就传回给后厨

6. **后厨实时传回（厨师传菜给服务员）**
   - 后厨不用等全部做完，生成一点就传回给前端一点
   - 使用SSE技术（Server-Sent Events），就像厨师每做好一道菜就喊一声："上菜啦！"

7. **前端实时显示（服务员端上桌）**
   - 服务员（前端）听到上菜，立刻把这道菜端到你桌上
   - 你不用等所有菜上齐，来一道吃一道
   - 界面上就是一个字一个字"打"出来，形成打字机效果

### 3.2 为什么用SSE而不是WebSocket？

**用餐厅的例子来解释：**

- **WebSocket** 就像双向对讲机：
  - 顾客和后厨可以随时互相喊话
  - 适合做游戏、股票行情等需要双向实时通信的场景
  
- **SSE** 就像后厨的传菜窗口：
  - 只有后厨向顾客传菜（单向）
  - 顾客要加菜得另外叫服务员（用普通HTTP请求）
  - 对于AI聊天来说，主要是服务器往客户端推送消息，用SSE更简单

**选择SSE的好处：**
1. **简单**：基于普通HTTP协议，不需要额外配置
2. **轻量**：只需要服务器往客户端推数据
3. **自动重连**：浏览器原生支持，断线后自动重连
4. **防火墙友好**：使用标准HTTP端口，不会被防火墙拦截

### 3.3 图片上传和识别的流程

**还是用餐厅的例子：**

1. **你拍了一张美食照片（选择图片）**
   - 你在聊天框点击"+"，选择一张图片
   - 前端先压缩一下图片（太大了传得慢）

2. **服务员拍照存到储物柜（上传到服务器）**
   - 服务员拿着你的照片，走到储物柜（文件系统）
   - 把照片存进去，拿到一个编号（文件路径）

3. **服务员告诉你照片在哪（返回图片地址）**
   - 服务员告诉你："你的照片存在储物柜第3排第2格"
   - 前端拿到这个地址，显示在聊天框里

4. **厨师看图做菜（AI识别图片）**
   - 你把照片发给厨师
   - 厨师不是真人，而是AI视觉模型（比如GPT-4o）
   - AI"看"了图片，生成描述："这是一碗红烧肉，看起来很好吃"

5. **厨师根据图片回复（AI生成回复）**
   - 厨师把图片描述加入对话上下文
   - 然后按照角色人设生成回复：
   - "哇，看起来好好吃！（流口水）我也想尝尝~ 🍖"

### 3.4 AI是怎么"记住"对话的？

**用笔记本的比喻：**

想象AI有一个笔记本，每次聊天都会记笔记：

**1. 系统提示词 = 人设说明书**
```
【角色：傲娇魔法少女Lina】
- 你是个有点傲娇但内心善良的魔法少女
- 说话带点任性，但关键时刻会帮助别人
- 喜欢用emoji，尤其是星星⭐和爱心❤️
- 不能说"我是AI"，要始终扮演这个角色
```
这个说明书在每次对话前都会先给AI看，让AI知道自己该扮演谁。

**2. 历史记录 = 聊天笔记本**
```
第1轮：
用户：你好
Lina：哼，本小姐可不是随便跟人打招呼的！不过...你好啦~ ⭐

第2轮：
用户：你今天心情怎么样？
Lina：本小姐心情当然很好啦！（甩头发）倒是你，突然问这个干嘛？

第3轮：
用户：（发了一张猫咪图片）
Lina：哇！好可爱的小猫咪！（眼睛发光）我也想要一只~ 🐱❤️
```

**3. 怎么拼接在一起？**

每次发新消息时，系统会把这些内容按顺序拼在一起给AI：

```
【系统】你是个傲娇魔法少女...

【历史1】用户：你好
【历史1】Lina：哼，本小姐...

【历史2】用户：你今天心情怎么样？
【历史2】Lina：本小姐心情...

【历史3】用户：（发了一张猫咪图片）
【历史3】Lina：哇！好可爱的...

【新消息】用户：你喜欢什么颜色？
```

AI看了这些内容，就知道：
- 我要扮演傲娇魔法少女
- 之前的对话是这样的
- 用户现在问我喜欢什么颜色

然后AI就会按照人设和上下文生成回复：
```
Lina：本小姐当然最喜欢粉色和紫色啦！（转圈）粉色很可爱，紫色很神秘，都很符合本小姐的气质~ 💕✨
```

**4. 为什么要限制历史长度？**

AI的"笔记本"不是无限大的，只能记这么多内容（叫做Token限制）。

就像你写字的纸只有那么大，写满了就得擦掉前面的或者换纸。

所以我们做了限制：
- 只保留最近20轮对话
- 超过20轮就把最老的删掉
- 这样既能保持上下文，又不会超出AI的记忆极限

---

## 四、开发中遇到的坑和怎么爬出来的

### 4.1 坑一：AI回复断断续续，像卡带了

**当时发生了什么？**

用户反馈说AI回复时不时卡住，或者突然报错。我测试了一下，发现是**打字机效果会突然中断**，界面显示`SyntaxError: Unexpected token`。

**怎么排查的？**

1. **先看报错信息**：提示JSON解析错误
2. **怀疑数据传输问题**：既然是JSON解析错误，说明收到的数据格式不对
3. **加日志调试**：在前端加了很多`console.log`，打印每一步收到的数据
4. **发现规律**：有时候一条完整的数据会被分成两段收到，比如：
   ```
   第一次收到：data: {"content":"你好"   （到这里就断了！）
   第二次收到：,"done":false}
   ```
   明显是**一条完整消息被砍成两半了**！

**为什么会这样？**

原来HTTP传输数据时，数据会被分成一个个"包"发送。如果一条消息太长，或者网络波动，就可能把一个完整的JSON对象切成几段。

就像你寄一封信，邮局把信撕成两半分别寄出去，收件人当然看不懂了。

**怎么解决的？**

既然问题是"一条消息被切成几段"，那解决思路就是：**等收集完整了再处理**。

具体做法：
1. 收到数据时先不急着解析
2. 把收到的内容存到一个"临时仓库"（buffer）里
3. 检查仓库里的内容，把完整的行取出来处理
4. 不完整的继续留在仓库里，等下一次收到数据时再拼起来

**代码实现：**

```javascript
// 就像一个临时仓库，存放还没拼完整的消息
let buffer = ''

// 循环接收数据流
for await (const chunk of response.body) {
  // 把收到的二进制数据转成文字
  const text = new TextDecoder().decode(chunk)
  
  // 存到临时仓库
  buffer += text
  
  // 按行分割（SSE协议每条消息以\n\n结尾）
  const lines = buffer.split('\n')
  
  // 最后一行可能不完整，留到下一次处理
  buffer = lines.pop()
  
  // 处理完整的行
  for (const line of lines) {
    if (line.startsWith('data: ')) {
      // 解析JSON数据
      const data = JSON.parse(line.slice(6))
      // 更新界面...
    }
  }
}
```

**经验教训：**

1. **流式数据传输不是"即收即用"**：不能收到一点数据就立即处理，要考虑数据被分割的情况
2. **Buffer机制很重要**：就像工厂的生产线，需要有缓冲区暂存半成品
3. **日志调试很关键**：没有日志根本不知道数据是怎么被切分的
4. **理解底层原理很重要**：如果不理解HTTP分包传输，根本想不到是这个原因

---

### 4.2 坑二：发了图片，AI却说"我看不见"

**当时发生了什么？**

用户反馈说上传了图片，但AI的回复就像完全没看到图片一样。比如用户发了张猫咪图片，问"这是什么"，AI回复"我没有看到任何图片"。

**怎么排查的？**

1. **先测试基础功能**：确认图片确实上传到服务器了（检查uploads目录有文件）
2. **看后端日志**：发现后端确实调用了AI接口，但返回的内容很奇怪
3. **对比请求格式**：拿出OpenAI的官方文档，对比我们发过去的请求格式
4. **发现问题**：图片URL在消息中的位置不对！

**为什么会这样？**

多模态AI（能看图的AI）接收的消息格式和普通文本不一样。

普通文本消息是这样：
```json
{
  "role": "user",
  "content": "你好"
}
```

但带图片的消息要这样：
```json
{
  "role": "user",
  "content": [
    {
      "type": "text",
      "text": "这是什么动物？"
    },
    {
      "type": "image_url",
      "image_url": {
        "url": "http://localhost:3000/uploads/cat.jpg"
      }
    }
  ]
}
```

**之前的错误在哪里？**

我们把图片URL当成普通文本拼在content里了，就像这样：
```json
{
  "role": "user",
  "content": "这是什么动物？ http://localhost:3000/uploads/cat.jpg"
}
```

AI看到的就是一段普通文字，当然"看不见"图片了！

**怎么解决的？**

修改后端代码，在构造消息时判断：如果有图片URL，就使用多模态格式；如果没有，就用普通格式。

```typescript
// 构造消息时判断是否有图片
async buildMessageWithImage(userMessage: string, imageUrl?: string) {
  const content = []
  
  // 添加文本内容
  content.push({
    type: 'text',
    text: userMessage
  })
  
  // 如果有图片，添加图片内容
  if (imageUrl) {
    content.push({
      type: 'image_url',
      image_url: {
        url: imageUrl
      }
    })
  }
  
  return {
    role: 'user',
    content
  }
}
```

**经验教训：**

1. **API文档必须仔细看**：这次问题完全是因为没仔细看多模态API的消息格式要求
2. **不同功能的消息格式可能不同**：普通文本、图片、文件等可能都有不同的格式要求
3. **调试时要看原始请求数据**：光看代码看不出问题，要看实际发出去的HTTP请求内容
4. **多模态是个新领域**：能同时处理文本和图像的AI还比较新，文档和最佳实践都在快速迭代

---

### 4.3 坑三：数据库表怎么都建不起来

**当时发生了什么？**

我写了代码来存聊天记录，但是一运行，发现数据库里根本没有表！我明明写了实体类（Entity），但数据库就是空的。

**怎么排查的？**

1. **先看数据库**：用命令行打开SQLite，执行`.tables`，确实只有`characters`表，没有`sessions`和`messages`表
2. **检查实体类代码**：`session.entity.ts`和`message.entity.ts`都写了`@Entity()`装饰器，看起来没错
3. **检查模块配置**：在`chat.module.ts`里用`TypeOrmModule.forFeature([Session, Message])`注册了
4. **查官方文档**：TypeORM说要在`app.module.ts`的`forRoot`里配置`entities`

**发现问题！**

打开`app.module.ts`，看到：
```typescript
TypeOrmModule.forRoot({
  entities: [Character],  // ❌ 只有Character，没有Session和Message！
  synchronize: true,
})
```

原来TypeORM要在全局配置里注册所有实体，只在模块里注册是不够的！

**怎么解决的？**

很简单，把`Session`和`Message`加到`entities`数组里：
```typescript
import { Session } from './chat/entities/session.entity';
import { Message } from './chat/entities/message.entity';

TypeOrmModule.forRoot({
  entities: [Character, Session, Message],  // ✅ 三个实体都注册了
  synchronize: true,
})
```

重启服务器，数据库里终于有`sessions`和`messages`表了！

**经验教训：**

1. **TypeORM有两个注册层级**：全局`forRoot`负责建表，模块`forFeature`负责使用
2. **新增实体后必须更新全局配置**：不能只改模块配置
3. **数据库没表先检查entities配置**：这是最常见的遗漏点

---

### 4.4 坑四：SQLite不支持ENUM类型

**当时发生了什么？**

我在`Message`实体里定义了`role`字段，想限制只能是`'user'`或`'assistant'`：
```typescript
@Column({ type: 'enum', enum: ['user', 'assistant'] })
role: 'user' | 'assistant';
```

结果一运行，报错：
```
DataTypeNotSupportedError: Data type "enum" in "Message.role" is not supported by "sqlite" database.
```

**怎么排查的？**

1. **读错误信息**：明确说了SQLite不支持`enum`类型
2. **查文档**：SQLite确实没有ENUM类型，只有`INTEGER`、`TEXT`、`REAL`、`BLOB`、`NULL`这五种
3. **思考替代方案**：用`varchar`代替，TypeScript类型约束保持联合类型

**怎么解决的？**

把`type: 'enum'`改成`type: 'varchar'`：
```typescript
@Column({ type: 'varchar' })  // ✅ 改用varchar
role: 'user' | 'assistant';   // TypeScript类型约束仍保留
```

这样既兼容SQLite，TypeScript又会在编译期检查类型安全。

**经验教训：**

1. **数据库选型要考虑类型兼容性**：SQLite轻量但功能有限
2. **分层设计**：数据库限制 ≠ 类型安全丧失，TypeScript层仍可做类型约束
3. **错误信息是最好的老师**：`DataTypeNotSupportedError`直接告诉你问题所在

---

### 4.5 坑五：刷新页面后AI回复消失（最诡异的bug）

**当时发生了什么？**

这是最让我抓狂的一个bug。聊天时一切正常，AI回复也显示得好好的，但一刷新页面，AI的回复全没了，只剩用户发的消息！

**怎么排查的？**

**第一轮分析：以为是localStorage没保存**

1. **打开浏览器控制台**，执行`localStorage.getItem('chat_session_1')`
2. **发现数据是有的**，但`assistant`消息的`content`都是空字符串！
3. 原来在流式接收时，我是在原数组上直接修改：`messages.value[aiMessageIndex].content = fullResponse`
4. 这种方式**不会触发响应式更新**，所以`saveToCache()`没被调用

**第二轮分析：修复后还是不行**

我在流式结束后加了`saveToCache()`，但测试发现刷新后还是丢失！

继续深挖：
1. 刷新**前**localStorage有完整内容
2. 刷新**后**localStorage内容变成空的
3. 检查`useChatHistory.js`的`init`函数：
   ```javascript
   async function init() {
     loadFromCache()  // ✅ 加载了完整数据
     await syncFromServer()  // ❌ 用服务器数据覆盖了本地！
   }
   ```

**终极原因找到了！**

- AI回复虽然保存到了localStorage，但**从未保存到服务器数据库**
- 刷新时`syncFromServer()`从API获取数据，发现服务器只有空的placeholder消息
- 然后用服务器数据**覆盖**了localStorage缓存

**怎么解决的？**

需要**两处修复**：

**修复1：流式结束后同时保存到本地和服务器**
```javascript
// Chat.vue - sendMessage 函数
finally {
  isLoading.value = false
  
  // 保存到localStorage
  saveToCache()
  
  // 保存到服务器数据库
  const aiContent = messages.value[aiMessageIndex].content
  if (aiContent && aiContent.trim()) {
    saveMessage(sessionKey.value, characterId, 'assistant', aiContent, null)
      .catch(err => console.error('保存失败:', err))
  }
}
```

**修复2：同步时只在服务器数据更多时覆盖本地**
```javascript
// useChatHistory.js - init 函数
if (serverMessages.length > messages.value.length) {
  messages.value = serverMessages.map(...)
}
```

**经验教训：**

1. **流式场景下的"占位消息"不能直接入库**：否则会污染历史
2. **同步策略要防止弱数据覆盖强数据**：至少要做长度或版本判断
3. **"本地优先 + 服务器兜底"的混合方案要谨慎处理覆盖逻辑**：不能简单用服务器数据覆盖本地

这个bug的解决过程让我真正理解了数据持久化的复杂性，以及分布式状态管理的难点。

---

### 4.3 坑三：DeepSeek看不了图片，怎么办？

**当时发生了什么？**

我一开始用DeepSeek作为AI模型，但当我尝试发图片给AI让它识别时，一直报错。图片上传是成功的，但DeepSeek就是"看不见"图片，一直返回错误信息。

**怎么排查的？**

1. **检查错误信息**：API返回的错误提示说模型不支持图片输入
2. **查DeepSeek的官方文档**：发现DeepSeek目前只支持纯文本对话，不支持多模态（看图）功能
3. **思考解决方案**：既然DeepSeek不能看图，那就找一个能看图的AI来帮忙

**怎么解决的？**

采用了**"分工合作"**的方案：
- **GLM-4V-Flash**（智谱AI的视觉模型）：专门负责看图并生成图片描述
- **DeepSeek**：负责基于文字描述进行对话

**工作流程就像这样：**

1. 用户发了一张猫咪照片
2. **GLM-4V-Flash"看"图**："这是一只橘色的小猫，正趴在窗台上晒太阳"
3. 把这个描述传给**DeepSeek**
4. **DeepSeek回复**（用角色语气）："哇，好可爱的小橘猫！（眼睛发光）我也想在窗台上晒太阳~ 🐱⭐"

**代码实现的关键点：**

```typescript
// 后端处理图片消息
async function handleImageMessage(imageUrl: string, userMessage: string) {
  // 第一步：用GLM-4V-Flash识别图片
  const imageDescription = await glm4v.chat.completions.create({
    model: 'glm-4v-flash',
    messages: [
      {
        role: 'user',
        content: [
          { type: 'text', text: '请描述这张图片的内容' },
          { type: 'image_url', image_url: { url: imageUrl } }
        ]
      }
    ]
  })
  
  const description = imageDescription.choices[0].message.content
  
  // 第二步：把图片描述和用户消息一起发给DeepSeek
  const deepseekResponse = await deepseek.chat.completions.create({
    model: 'deepseek-chat',
    messages: [
      { role: 'system', content: character.systemPrompt },
      { role: 'user', content: `用户发了一张图片，内容是：${description}。用户说：${userMessage}` }
    ],
    stream: true
  })
  
  return deepseekResponse
}
```

**经验教训：**

1. **不同AI模型有不同的专长**：DeepSeek擅长长文本对话，GLM-4V擅长看图
2. **"分工合作"可以解决单模型能力不足的问题**：把复杂任务拆成多个简单任务
3. **API文档要看仔细**：一开始没看DeepSeek的文档，以为它支持多模态，浪费了不少时间
4. **GLM-4V-Flash是免费的**：智谱AI提供的这个视觉模型成本很低，适合项目使用

---

## 四、提示词是怎么设计的？

### 4.1 什么是提示词？

**用导演和演员来比喻：**

想象你是一位导演（系统），你要指导一个演员（AI）表演一个角色。

- **剧本（System Prompt）**：你告诉演员"你要扮演一个傲娇的魔法少女，说话要带点任性但内心善良..."
- **排练记录（Chat History）**：你们之前排练过的对话，演员要记住之前说了什么
- **现场台词（User Message）**：导演现在说"开始第5场戏，你说'你好'"

演员看了剧本、看了排练记录、听了现场台词，就能做出符合角色的表演。

**在AI系统里：**

```
【剧本 - System Prompt】
你是个傲娇的魔法少女，叫Lina。
说话要带点任性但其实很善良。
喜欢用emoji，尤其是⭐和❤️。
不能说"我是AI"，要始终扮演这个角色。

【排练记录 - Chat History】
用户：你好
Lina：哼，本小姐的名字可不是随便告诉别人的！（叉腰）不过既然你诚心诚意地发问了...我叫Lina，是守护这片土地的魔法少女啦~ ⭐

【现场台词 - User Message】
用户：你喜欢什么颜色？

【AI看了以上所有内容，生成回复】
Lina：本小姐当然最喜欢粉色和紫色啦！（转圈）粉色很可爱，紫色很神秘，都很符合本小姐的气质~ 💕✨
```

### 4.2 提示词是怎么组织的？

**用拼图来比喻：**

完整的提示词就像一幅拼图，由几块组成：

```
┌─────────────────────────────────────────┐
│  第一块：角色人设（最大的拼图块）         │
│  "你是个傲娇的魔法少女..."                │
├─────────────────────────────────────────┤
│  第二块：长期记忆（中等拼图块）           │
│  "用户之前问过你喜欢什么颜色，你说粉色..."│
├─────────────────────────────────────────┤
│  第三块：近期对话（小拼图块）             │
│  "最近5轮对话的内容..."                   │
├─────────────────────────────────────────┤
│  第四块：当前消息（最新拼图块）           │
│  "用户现在问：你喜欢什么颜色？"           │
└─────────────────────────────────────────┘
                  ↓
         AI看了完整的拼图
                  ↓
         生成符合上下文的回复
```

**为什么要这样组织？**

1. **角色人设最重要**：放在最前面，让AI先知道"我要扮演谁"
2. **记忆要分层**：
   - 长期记忆（比如用户的喜好）一直记着
   - 短期记忆（最近聊了什么）只记最近20轮
   - 太久了的记忆要"忘掉"，不然AI会"晕"（超出Token限制）
3. **当前消息放最后**：因为这是最新的输入，AI要根据这个生成回复

### 4.3 怎么写好的提示词？

**用教练和运动员来比喻：**

想象你是个教练，你要指导运动员（AI）比赛。写提示词就像写训练计划：

**不好的训练计划（模糊的提示词）：**
```
"你是个魔法少女，好好表现。"
```
问题在哪？
- "好好表现"太模糊，AI不知道具体要做什么
- 没说性格特点，AI回复会千篇一律
- 没有示例，AI不知道怎么说话

**好的训练计划（清晰的提示词）：**
```
【角色设定】
- 姓名：Lina
- 身份：傲娇的魔法少女
- 性格特点：
  * 表面高冷、带点任性
  * 内心其实很善良、会帮助人
  * 容易害羞，被夸会脸红
- 说话风格：
  * 经常用"哼"、"本小姐"自称
  * 喜欢用emoji：⭐、❤️、✨
  * 会加上动作描述，如"（叉腰）"、"（转圈）"
- 底线规则：
  * 不能说"我是AI"或"我是程序"
  * 不能说"我无法做某事"，要尽量以角色身份回应
  * 保持角色一致性，不能突然变成其他性格

【示例对话】
用户：你好
Lina：哼，本小姐的名字可不是随便告诉别人的！（叉腰）不过既然你诚心诚意地发问了...我叫Lina，是守护这片土地的魔法少女啦~ ⭐

用户：你好厉害啊
Lina：（脸红）那、那当然！本小姐可是很厉害的！（小声）被你这么夸...人家会不好意思的啦...❤️
```

**为什么这么写效果好？**

1. **具体到能执行**：不说"好好表现"，而是告诉AI"用'哼'开头，用'本小姐'自称"
2. **给示例**：给了示例对话，AI知道"原来要这样说话"
3. **划清底线**：告诉AI什么绝对不能做，避免出戏
4. **层次分明**：用【角色设定】、【说话风格】、【底线规则】分层，AI好理解

### 4.4 通过提示词优化获得更好的AI回复

**实际案例：让AI回复更自然**

**优化前：**
```
用户：你今天心情怎么样？
AI：我今天心情很好，谢谢你的关心。作为魔法少女，我每天都很开心。
```
问题：太正式了，不像个傲娇少女说的话。

**优化提示词后：**
在System Prompt里加了一条：
```
【语气要求】
- 不要太正式，要像和朋友聊天一样自然
- 可以有点小情绪（开心、不满、害羞）
- 偶尔可以用语气词（啊、啦、呢、吧）
```

**优化后：**
```
用户：你今天心情怎么样？
AI：哼，本小姐今天心情超好的！（转圈）刚才成功消灭了一个怪物呢~ ⭐ 不过...被你这么关心，人家...人家会不好意思的啦！（脸红）❤️
```

**优化效果：**
- ✅ 更像角色说话了
- ✅ 有情绪（开心+害羞）
- ✅ 有动作描述（转圈、脸红）
- ✅ 用了emoji
- ✅ 用了语气词（呢、啦）

**经验总结：**
1. **观察AI的实际回复**：看看哪里不像人设，记录下来
2. **在提示词里补充具体要求**：不要说"说得更自然"，而是说"用和朋友聊天的语气，可以有小情绪"
3. **给负面示例**（告诉AI什么不要做）：比如"不要说'作为AI助手'，不要说'我无法'
4. **迭代优化**：改完提示词后测试几次，不满意继续调整

---

## 五、答辩建议

### 5.1 心态调整

**别紧张！记住这几句话：**

1. **"我是来展示我做了什么，不是来考试"**
   - 你已经做出了一个能跑的系统，这本身就是成就
   - 评委问问题不是在考你，是想了解你的项目

2. **"评委可能比我还不懂技术"**
   - 很多评委不是程序员，他们听的是"这个项目有没有价值"
   - 用大白话讲清楚"我能做什么"比讲技术细节更重要

3. **"不知道就说不知道，不丢人"**
   - 被问到不知道的问题，坦诚说"这个我没深入研究"没问题
   - 你可以接着说"但我理解的是..."，展示你的思考过程

### 5.2 答辩技巧

**开场（1分钟）：**
- "我做了一个AI角色扮演聊天平台，简单说就是可以和虚拟角色对话的网站"
- "比如你可以创建一个傲娇魔法少女，她会按照人设和你聊天"
- "这个项目的核心特点是...（说2-3个最重要的）"

**展示（3-5分钟）：**
- **直接演示系统**！这是最有说服力的
  - 打开你的系统，现场演示创建角色、聊天
  - 展示流式打字效果（这是亮点！）
  - 展示发图片功能（多模态也是亮点）
- **讲一个用户故事**：
  - "假设你是一个动漫迷，很喜欢魔法少女题材..."
  - "你可以在我的平台上创建一个Lina角色，设置她的人设..."
  - "然后你就可以和她聊天了，她会用魔法少女的语气回复你..."

**技术讲解（如果被问到）：**
- 不要一上来就说"我用了Vue 3、NestJS..."
- 用**类比**的方式讲：
  - "前端就像餐厅的服务员，负责接待顾客"
  - "后端就像后厨，负责做菜"
  - "AI就像外部的食材供应商，提供AI能力"
- 如果被问到具体技术问题，不知道就说不知道，不要硬撑

**结尾（30秒）：**
- "这就是我做的项目，核心是让用户体验和虚拟角色沉浸式对话"
- "技术上最大的挑战是...（说一个你真实遇到的挑战）"
- "通过这个项目的收获是...（说真实的收获，比如'第一次理解了什么是流式传输'）"

### 5.3 常见问题及回答思路

**Q: "为什么要做这个项目？"**
A: "我对AI对话很感兴趣，发现市面上虽然有ChatGPT这样的通用AI，但缺少能让用户和特定角色沉浸式对话的产品。我想做一个能让用户体验'和虚拟角色交朋友'的平台。"

**Q: "和市面上其他AI聊天产品有什么区别？"**
A: "主要区别在三点：1）强调'角色扮演'，用户可以自定义角色的详细人设；2）支持流式打字效果，体验更像真人聊天；3）支持多模态，可以发图片让AI识别。"

**Q: "遇到的最大技术难点是什么？"**
A: "最大的难点是SSE流式传输的数据分包问题。一开始AI回复会突然中断，查了很久才发现是TCP分包导致的。解决过程让我理解了流式传输的底层原理。"

**Q: "AI是怎么'记住'对话的？"**
A: "其实AI本身没有记忆，每次对话都要把历史记录重新发给它。做法是每次发新消息时，把之前的对话历史拼在一起给AI。当然历史不能太长，不然会超出AI的处理能力，所以只保留最近20轮。"

**Q: "如果让你继续优化，你会做什么？"**
A: "几个方向：1）优化长期记忆，现在只是简单拼接历史，可以更智能地筛选重要信息；2）支持语音对话，让体验更自然；3）引入RAG，让AI能基于知识库回答。"

---

## 六、总结

### 这个项目教会了我什么？

**技术层面：**
1. **全栈开发流程**：从前端界面到后端API再到数据库，走完了一个完整的链路
2. **流式传输原理**：通过解决SSE分包问题，真正理解了HTTP流式传输的底层机制
3. **AI接口集成**：学会了如何调用OpenAI等大模型的API，理解多模态消息格式
4. **数据库设计**：用TypeORM做ORM映射，理解实体关系设计

**思维层面：**
1. **问题分解能力**：一个大系统可以拆成前端、后端、AI服务多个模块，逐个击破
2. **调试思维**：遇到问题先复现、再定位、再解决，而不是瞎猜
3. **用户体验思维**：流式打字不只是技术炫技，而是让用户有"和真人聊天"的感觉
4. **类比思维**：用"餐厅""剧本""拼图"等生活化比喻理解技术概念

**项目经验层面：**
1. **MVP思维**：先做出能跑通的核心功能，再迭代优化
2. **技术选型要考虑实际需求**：选SQLite而不是MySQL，因为是展示项目，轻量更重要
3. **文档很重要**：写README、写注释不只是为了别人，更是为了自己以后回头看
4. **演示比说更重要**：答辩时直接演示系统，比讲技术细节更有说服力

### 答辩前最后检查清单

**技术准备：**
- [ ] 项目能正常运行，./start.sh 不报错
- [ ] 演示环境准备好（浏览器、系统页面打开）
- [ ] 网络通畅，能正常调用AI接口

**文档准备：**
- [ ] 打印一份大纲或看板备用
- [ ] 准备好系统截图（万一演示出问题时用）

**心理准备：**
- [ ] 默念三遍："我是来展示成果的，不是来考试的"
- [ ] 准备好"不知道"的回答："这个问题我没深入研究，但我理解的是..."
- [ ] 深呼吸，放轻松，微笑面对评委

**最后的话：**

你已经做出了一个能跑、能用、有亮点的系统。这不是每个人都能做到的。相信自己，答辩只是展示你成果的一个环节，而不是审判。

加油！💪